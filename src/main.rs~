use rhai::{Engine, EvalAltResult};
use regex::Regex;

struct CellRef {
    row: usize,
    col: usize,
}
impl CellRef {
    fn new(row: usize, col: usize) -> CellRef {
	CellRef {
	    row,
	    col
	}
    }
    fn from_str(name: &str) -> Option<CellRef> {
        let re = Regex::new(r"^(?<letters>[A-Za-z]+)(?<numbers>[0-9]+)$").unwrap();
        let caps = re.captures(name)?;
        let letters = &caps["letters"];
        let numbers = &caps["numbers"];

        // Convert letters to column index (A=0, B=1, ..., Z=25, AA=26, etc.)
        let col = letters
            .to_ascii_uppercase()
            .bytes()
            .fold(0usize, |acc, c| acc * 26 + (c - b'A') as usize + 1)
            - 1;

        // Convert 1-indexed row to 0-indexed
        let row = numbers.parse::<usize>().ok()?.checked_sub(1)?;

        Some(CellRef::new(row, col))
    }
}
enum CellType {
    Empty,
    Text(String),
    Number(f64),
    Script(String),
}

struct Cell {
    location: CellRef,
    contents: CellType,
    depends_on: Vec<CellRef>,
    dirty: bool,
}

fn main() -> Result<(), Box<EvalAltResult>>{
    let a1 = Cell{
	location: CellRef::new(0,0),
	contents: CellType::Script("print(40 + 20)".to_string()),
	depends_on: vec!(),
	dirty: true,
    };
    
    let cells = vec!(a1);
    
    let engine = Engine::new();

    for cell in cells {
	match cell.contents {
	    CellType::Script(s) => engine.run(&s)?,
	    _ => println!("Not implemented cell type"),
	}
    }

    Ok(())
}

